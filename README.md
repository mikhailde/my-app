# Оптимизированный CI/CD пайплайн для приложения "Hello, World!" на Kubernetes

Этот репозиторий демонстрирует создание и оптимизацию CI/CD пайплайна для простого веб-приложения "Hello, World!" на Python, развернутого в кластере Kubernetes (Minikube). Пайплайн включает сборку Docker-образа, тестирование, развертывание и мониторинг с помощью Prometheus, Grafana и Alertmanager.  Canary deployments управляются с помощью Flagger.

## Архитектура

Ниже представлена диаграмма, иллюстрирующая архитектуру CI/CD пайплайна:

![Архитектура CI/CD](./architecture.svg)  *(Замени `./architecture.svg` на фактический путь к твоему изображению)*


**Описание компонентов и потоков данных:**

1. **GitLab CI/CD:** Оркестрирует весь процесс CI/CD, запуская пайплайн при каждом изменении кода в репозитории.
2. **Kaniko:** Инструмент для сборки Docker-образов внутри Kubernetes, без необходимости использования Docker daemon.
3. **Docker Image Registry (GitLab Registry):** Хранит Docker-образы приложения.
4. **Minikube:** Локальный кластер Kubernetes для развертывания приложения.
5. **Helm:**  Используется для управления развертыванием приложения в Kubernetes.
6. **Terraform:**  Управляет инфраструктурой Kubernetes декларативно, применяя изменения к конфигурации Minikube.
7. **Приложение "Hello, World!":**  Простое веб-приложение на Python, которое используется в качестве примера.
8. **Prometheus:** Собирает метрики с приложения, Kubernetes и GitLab CI/CD.
9. **Grafana:**  Визуализирует метрики, собранные Prometheus, предоставляя дашборды для мониторинга.
10. **Alertmanager:** Обрабатывает оповещения от Prometheus и отправляет уведомления (например, на почту).
11. **Flagger:** Автоматизирует canary deployments, постепенно перенаправляя трафик на новую версию приложения и анализируя метрики для определения успешности развертывания.

**Поток данных:**

1. **Сборка:**  После пуша кода в репозиторий GitLab CI/CD запускает Kaniko для сборки Docker-образа и отправляет его в GitLab Registry.
2. **Тестирование:** После сборки запускаются юнит-тесты, проверяющие корректность работы приложения.
3. **Развертывание:** Успешно собранный и протестированный образ деплоится в Minikube с помощью Helm и Terraform. Flagger создает canary deployment для новой версии.
4. **Мониторинг:** Prometheus собирает метрики с приложения, Kubernetes (включая состояние pod'ов, deployments, ресурсов) и GitLab CI/CD (время выполнения заданий, количество ошибок и т.д.). Grafana отображает эти метрики на дашбордах.
5. **Оповещения:**  Alertmanager получает оповещения от Prometheus о проблемах (например, высокая нагрузка на CPU, ошибки в приложении) и отправляет уведомления.


## Оптимизации

В этом пайплайне реализованы следующие оптимизации:

* **Многоступенчатая сборка Docker:** Уменьшает размер итогового образа.
* **Кэширование зависимостей:**  Ускоряет установку зависимостей Python.
* **Параллелизация тестов:** Сокращает общее время тестирования.
* **Инфраструктура как код (Terraform):**  Автоматизирует управление инфраструктурой и обеспечивает идемпотентность развертывания.
* **Canary deployments (Flagger):**  Обеспечивает безопасный и постепенный rollout новых версий.

## Инструкция по запуску

1. **Предварительные требования:**  Убедитесь, что у вас установлены и настроены следующие инструменты:
    * `kubectl`
    * `helm`
    * `docker`
    * `terraform`
    * `python3`
    * Аккаунт на GitLab

2. **Клонируйте репозиторий:**
   ```bash
   git clone <ваш_репозиторий>
   ```

3. **Запустите Minikube:**
   ```bash
   minikube start
   ```

4. **Разверните Prometheus, Grafana и Flagger:**
   ```bash
   helm install prometheus prometheus-community/prometheus
   helm install grafana grafana/grafana
   helm install flagger flagger/flagger --namespace=flagger --create-namespace -f k8s/flagger-values.yaml
   kubectl apply -f k8s/canary.yaml
   ```

5. **Настройте GitLab CI/CD:**
    * Создайте новый проект в GitLab и импортируйте код из клонированного репозитория.
    * Добавьте следующие переменные окружения в настройки CI/CD проекта:
        * `TF_VAR_image_registry`:  Адрес вашего реестра образов Docker (например, `registry.gitlab.com/<ваш_username>`)
        * `TF_CLI_CONFIG_FILE`:  Путь к файлу `config.tfrc`.
        * `KUBECONFIG`: base64 закодированный kubeconfig файл minikube

6. **Запуште код в репозиторий GitLab:** Это автоматически запустит CI/CD пайплайн.

7. **Откройте Grafana:**
   ```bash
   kubectl port-forward svc/grafana 3000:80 -n monitoring
   ```
   Перейдите в браузере по адресу  `http://localhost:3000`.

8. **Импортируйте дашборды Grafana:**  Импортируйте дашборды из файлов `grafana/cicd.json` и `grafana/app_preformance.json`.

## Результаты

После успешного завершения пайплайна:

* Приложение будет развернуто в Minikube.  Доступ к нему можно будет получить через NodePort, назначенный сервисом Kubernetes.
* В Grafana будут доступны дашборды для мониторинга производительности приложения и состояния CI/CD процесса.

## Дальнейшие улучшения

* **Более  сложные  тесты:**   Добавьте  интеграционные  и  end-to-end  тесты. 
* **Автоматизация  canary  анализа:**   Используйте  метрики  Prometheus  для  автоматического  определения  успешности  canary  деплоев  с  помощью  Flagger. 
* **Оптимизация  ресурсов  Kubernetes:**   Настройте  лимиты  и  реквесты  ресурсов  для  pod'ов. 


## Заключение

Этот проект  демонстрирует  эффективный  подход  к  построению  и  оптимизации  CI/CD  пайплайна.  Он  может  быть  использован  в  качестве  базы  для  создания  более  сложных  пайплайнов  и  адаптирован  под  различные  проекты. 
stages:
  # - build
  # - test
  # - deploy_helm
  - deploy_tf

# build:
#   stage: build
#   image:
#     name: gcr.io/kaniko-project/executor:debug
#     entrypoint: [""]
#   script:
#     - echo "{\"auths\":{\"${CI_REGISTRY}\":{\"auth\":\"$(printf "%s:%s" "${CI_REGISTRY_USER}" "${CI_REGISTRY_PASSWORD}" | base64 | tr -d '\n')\"}}}" > /kaniko/.docker/config.json
#     - /kaniko/executor --context "${CI_PROJECT_DIR}"
#       --dockerfile "${CI_PROJECT_DIR}/Dockerfile"
#       --destination "${CI_REGISTRY_IMAGE}:latest"
#       --cache=true
#       --cache-repo=${CI_REGISTRY_IMAGE}/cache

# .default_test:
#   stage: test
#   image: python:latest
#   before_script:
#     - python -m venv venv
#     - source venv/bin/activate
#     - pip install -r requirements.txt
#   cache:
#     key: ${CI_COMMIT_REF_SLUG}
#     paths:
#       - venv/
#     policy: pull-push

# test_util:
#   extends: .default_test
#   script:
#     - if [ "$CI_NODE_INDEX" == "1" ]; then python -m unittest tests.test_app.TestUtil1; fi
#     - if [ "$CI_NODE_INDEX" == "2" ]; then python -m unittest tests.test_app.TestUtil2; fi
#   parallel: 2

# test_flask_app:
#   extends: .default_test
#   script:
#     - python -m unittest tests.test_app.TestFlaskApp

# deploy_helm:
#   stage: deploy_helm
#   image: dtzar/helm-kubectl
#   script:
#     - helm upgrade --install my-app ./chart
#       --set image.tag=latest
#       --set image.repository=$CI_REGISTRY_IMAGE
#       --namespace my-app --create-namespace
#     - kubectl rollout restart deployment my-app -n my-app


deploy_tf:
  stage: deploy_tf
  # image: hashicorp/terraform:light
  variables:
    TF_VAR_image_registry: $CI_REGISTRY_IMAGE
    # TF_CLI_CONFIG_FILE: "config.tfrc"
  # cache:
  #   key: ${CI_COMMIT_REF_SLUG}
  #   paths:
  #     - terraform/
  #   policy: pull-push
  before_script:
    - cd terraform
    - gitlab-terraform init
  script:
    - gitlab-terraform plan -out=tfplan
    - gitlab-terraform apply -input=false tfplan
